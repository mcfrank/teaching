---
title: "Pareto efficiency analysis in RWebPPL"
author: "Larry Liu and Michael C. Frank"
date: "`r Sys.Date()`"
output: 
  html_document:
  toc: true
number_sections: true
---
  
```{r, echo = FALSE, include = FALSE}
rm(list=ls())
library(tidyverse)
library(rwebppl)
library(knitr)
opts_chunk$set(echo=FALSE, cache=TRUE, warning=FALSE, message = FALSE)
theme_set(theme_bw())
```

# Pipeline sanity check
```{r}
test_model <- "
var model = function() {
  console.log(\"Hello world\")
  return mathBeta.beta(3,5);
}
model();
"
webppl(test_model, packages = c("webppl/node_modules/webppl-beta"))

```

# Single student

```{r}
out <- as.data.frame(webppl(program_file = "webppl/scripts/bayesianTeacher.js", packages = c("webppl/node_modules/webppl-compute-digamma/", "webppl/node_modules/webppl-beta")))
```

Write the data to an intermediate caching csv for external/reproducibility use

```{r}
write.csv(out, file='raw_data.csv')
```

Load packages for simulations
```{r}
library('tidyverse')
library('ggplot2')
library('Rmisc')
```

Load data for simulations
```{r}
df <- read.csv(file = 'raw_data.csv')
```

```{r, echo=FALSE}
#Some helper functions

#Get upper confidence interval
CI.high <- function(x){
  return(CI(x)['upper'])
}

#Get lower confidence interval
CI.low <- function(x){
  return(CI(x)['lower'])
}

#Minimum non-zero number
minNonZero <- function(x){
  return(min(x[x>0]))
}
```

Try running a simulation

Here, we calculate the score above the baseline that sorting a roster based on teacher beliefs of student understanding yields. Baseline is the student information gain given the same target concept with an unsorted roster randomly distributed to teachers. All simulations performed with 100 students and 5 teachers.
```{r}
for(rowNum in 1:nrow(df)){
  #Baselines for numteachers
  currIG <- df[rowNum, "IG"]
  baseline <- df[rowNum - (rowNum - 1)%%2]
  baseline <- df[rowNum - ((rowNum - 1) %% 10 + 1) + 1, "IG"] #TODO: write a generalized version of this using aggregate. See pareto block
  diff <- currIG - baseline
  df[rowNum, "scoreAboveBaseline"] <- if(abs(diff) < 1e-10) 0.0 else diff
  
  #Baslines for sorting
  sortingBaseline <- df[floor((rowNum+1)/2) * 2 - 1, "IG"]
  sortingDiff <- currIG - sortingBaseline
  df[rowNum, "scoreAboveSortingBaseline"] <- if(abs(diff) < 1e-10) 0.0 else sortingDiff
}
```

# Single student with teacher

```{r}
out <- webppl(program_file = "webppl/single_student.js")
```

We select HMC as our inference method, revisit this. 

Plot output. 

```{r}
qplot(support, prob, data = out) + 
  xlim(c(0,1)) + 
  ylim(c(0,max(out$prob)))
```

# Single student with teacher

```{r}
out <- webppl(program_file = "webppl/single_student_with_teacher.js")
```

We select HMC as our inference method, revisit this. 

Plot output. 

```{r}
qplot(support, prob, data = out) + 
  xlim(c(0,1)) + 
  ylim(c(0,max(out$prob)))
```
